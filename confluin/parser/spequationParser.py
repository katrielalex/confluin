# -*- coding: utf-8 -*-
# Generated from confluin/parser/spequation.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write('\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\17')
        buf.write('n\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b')
        buf.write('\t\b\4\t\t\t\4\n\t\n\4\13\t\13\3\2\3\2\6\2\31\n\2\r\2')
        buf.write('\16\2\32\3\3\3\3\5\3\37\n\3\3\3\3\3\3\3\5\3$\n\3\3\3\7')
        buf.write("\3\'\n\3\f\3\16\3*\13\3\3\3\5\3-\n\3\3\4\3\4\3\4\3\4\3")
        buf.write('\5\3\5\3\6\6\6\66\n\6\r\6\16\6\67\3\7\3\7\5\7<\n\7\3\7')
        buf.write('\3\7\3\7\5\7A\n\7\3\7\7\7D\n\7\f\7\16\7G\13\7\3\7\5\7')
        buf.write('J\n\7\3\b\3\b\5\bN\n\b\3\b\3\b\5\bR\n\b\3\b\3\b\3\t\3')
        buf.write('\t\5\tX\n\t\3\n\6\n[\n\n\r\n\16\n\\\3\13\3\13\3\13\3\13')
        buf.write('\3\13\5\13d\n\13\3\13\7\13g\n\13\f\13\16\13j\13\13\3\13')
        buf.write('\3\13\3\13\2\2\f\2\4\6\b\n\f\16\20\22\24\2\3\3\2\f\r\2')
        buf.write('t\2\30\3\2\2\2\4\34\3\2\2\2\6.\3\2\2\2\b\62\3\2\2\2\n')
        buf.write('\65\3\2\2\2\f9\3\2\2\2\16K\3\2\2\2\20W\3\2\2\2\22Z\3\2')
        buf.write('\2\2\24^\3\2\2\2\26\31\5\4\3\2\27\31\5\f\7\2\30\26\3\2')
        buf.write('\2\2\30\27\3\2\2\2\31\32\3\2\2\2\32\30\3\2\2\2\32\33\3')
        buf.write('\2\2\2\33\3\3\2\2\2\34\36\7\3\2\2\35\37\7\13\2\2\36\35')
        buf.write('\3\2\2\2\36\37\3\2\2\2\37 \3\2\2\2 (\5\6\4\2!#\7\4\2\2')
        buf.write("\"$\7\13\2\2#\"\3\2\2\2#$\3\2\2\2$%\3\2\2\2%\'\5\6\4\2")
        buf.write("&!\3\2\2\2\'*\3\2\2\2(&\3\2\2\2()\3\2\2\2),\3\2\2\2*(")
        buf.write('\3\2\2\2+-\7\n\2\2,+\3\2\2\2,-\3\2\2\2-\5\3\2\2\2./\5')
        buf.write('\n\6\2/\60\7\5\2\2\60\61\5\b\5\2\61\7\3\2\2\2\62\63\7')
        buf.write('\16\2\2\63\t\3\2\2\2\64\66\t\2\2\2\65\64\3\2\2\2\66\67')
        buf.write('\3\2\2\2\67\65\3\2\2\2\678\3\2\2\28\13\3\2\2\29;\7\6\2')
        buf.write('\2:<\7\13\2\2;:\3\2\2\2;<\3\2\2\2<=\3\2\2\2=E\5\16\b\2')
        buf.write('>@\7\4\2\2?A\7\13\2\2@?\3\2\2\2@A\3\2\2\2AB\3\2\2\2BD')
        buf.write('\5\16\b\2C>\3\2\2\2DG\3\2\2\2EC\3\2\2\2EF\3\2\2\2FI\3')
        buf.write('\2\2\2GE\3\2\2\2HJ\7\n\2\2IH\3\2\2\2IJ\3\2\2\2J\r\3\2')
        buf.write('\2\2KM\5\20\t\2LN\7\13\2\2ML\3\2\2\2MN\3\2\2\2NO\3\2\2')
        buf.write('\2OQ\7\7\2\2PR\7\13\2\2QP\3\2\2\2QR\3\2\2\2RS\3\2\2\2')
        buf.write('ST\5\20\t\2T\17\3\2\2\2UX\5\22\n\2VX\5\24\13\2WU\3\2\2')
        buf.write('\2WV\3\2\2\2X\21\3\2\2\2Y[\t\2\2\2ZY\3\2\2\2[\\\3\2\2')
        buf.write('\2\\Z\3\2\2\2\\]\3\2\2\2]\23\3\2\2\2^_\5\22\n\2_`\7\b')
        buf.write('\2\2`h\5\20\t\2ac\7\4\2\2bd\7\13\2\2cb\3\2\2\2cd\3\2\2')
        buf.write('\2de\3\2\2\2eg\5\20\t\2fa\3\2\2\2gj\3\2\2\2hf\3\2\2\2')
        buf.write('hi\3\2\2\2ik\3\2\2\2jh\3\2\2\2kl\7\t\2\2l\25\3\2\2\2\23')
        buf.write('\30\32\36#(,\67;@EIMQW\\ch')
        return buf.getvalue()


class spequationParser (Parser):

    grammarFileName = 'spequation.g4'

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        '<INVALID>', "'functions:'", "','", "'/'", "'equations:'",
        "'='", "'('", "')'", "'\n'",
    ]

    symbolicNames = [
        '<INVALID>', '<INVALID>', '<INVALID>', '<INVALID>',
        '<INVALID>', '<INVALID>', '<INVALID>', '<INVALID>',
        'EOL', 'WS', 'UPPER', 'LOWER', 'INTEGER', 'DIGIT',
    ]

    RULE_spec = 0
    RULE_functions = 1
    RULE_function = 2
    RULE_arity = 3
    RULE_name = 4
    RULE_equations = 5
    RULE_equation = 6
    RULE_term = 7
    RULE_base = 8
    RULE_application = 9

    ruleNames = [
        'spec', 'functions', 'function', 'arity', 'name', 'equations',
        'equation', 'term', 'base', 'application',
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    EOL = 8
    WS = 9
    UPPER = 10
    LOWER = 11
    INTEGER = 12
    DIGIT = 13

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion('4.7.1')
        self._interp = ParserATNSimulator(
            self, self.atn, self.decisionsToDFA, self.sharedContextCache,
        )
        self._predicates = None

    class SpecContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functions(self, i: int=None):
            if i is None:
                return self.getTypedRuleContexts(spequationParser.FunctionsContext)
            else:
                return self.getTypedRuleContext(spequationParser.FunctionsContext, i)

        def equations(self, i: int=None):
            if i is None:
                return self.getTypedRuleContexts(spequationParser.EquationsContext)
            else:
                return self.getTypedRuleContext(spequationParser.EquationsContext, i)

        def getRuleIndex(self):
            return spequationParser.RULE_spec

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterSpec'):
                listener.enterSpec(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitSpec'):
                listener.exitSpec(self)

    def spec(self):

        localctx = spequationParser.SpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_spec)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 22
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 22
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [spequationParser.T__0]:
                    self.state = 20
                    self.functions()
                    pass
                elif token in [spequationParser.T__3]:
                    self.state = 21
                    self.equations()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 24
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == spequationParser.T__0 or _la == spequationParser.T__3):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function(self, i: int=None):
            if i is None:
                return self.getTypedRuleContexts(spequationParser.FunctionContext)
            else:
                return self.getTypedRuleContext(spequationParser.FunctionContext, i)

        def WS(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.WS)
            else:
                return self.getToken(spequationParser.WS, i)

        def EOL(self):
            return self.getToken(spequationParser.EOL, 0)

        def getRuleIndex(self):
            return spequationParser.RULE_functions

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterFunctions'):
                listener.enterFunctions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitFunctions'):
                listener.exitFunctions(self)

    def functions(self):

        localctx = spequationParser.FunctionsContext(
            self, self._ctx, self.state,
        )
        self.enterRule(localctx, 2, self.RULE_functions)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 26
            self.match(spequationParser.T__0)
            self.state = 28
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == spequationParser.WS:
                self.state = 27
                self.match(spequationParser.WS)

            self.state = 30
            self.function()
            self.state = 38
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == spequationParser.T__1:
                self.state = 31
                self.match(spequationParser.T__1)
                self.state = 33
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == spequationParser.WS:
                    self.state = 32
                    self.match(spequationParser.WS)

                self.state = 35
                self.function()
                self.state = 40
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 42
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == spequationParser.EOL:
                self.state = 41
                self.match(spequationParser.EOL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(spequationParser.NameContext, 0)

        def arity(self):
            return self.getTypedRuleContext(spequationParser.ArityContext, 0)

        def getRuleIndex(self):
            return spequationParser.RULE_function

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterFunction'):
                listener.enterFunction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitFunction'):
                listener.exitFunction(self)

    def function(self):

        localctx = spequationParser.FunctionContext(
            self, self._ctx, self.state,
        )
        self.enterRule(localctx, 4, self.RULE_function)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.name()
            self.state = 45
            self.match(spequationParser.T__2)
            self.state = 46
            self.arity()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArityContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(spequationParser.INTEGER, 0)

        def getRuleIndex(self):
            return spequationParser.RULE_arity

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterArity'):
                listener.enterArity(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitArity'):
                listener.exitArity(self)

    def arity(self):

        localctx = spequationParser.ArityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_arity)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 48
            self.match(spequationParser.INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPPER(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.UPPER)
            else:
                return self.getToken(spequationParser.UPPER, i)

        def LOWER(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.LOWER)
            else:
                return self.getToken(spequationParser.LOWER, i)

        def getRuleIndex(self):
            return spequationParser.RULE_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterName'):
                listener.enterName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitName'):
                listener.exitName(self)

    def name(self):

        localctx = spequationParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 50
                _la = self._input.LA(1)
                if not(_la == spequationParser.UPPER or _la == spequationParser.LOWER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 53
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == spequationParser.UPPER or _la == spequationParser.LOWER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EquationsContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equation(self, i: int=None):
            if i is None:
                return self.getTypedRuleContexts(spequationParser.EquationContext)
            else:
                return self.getTypedRuleContext(spequationParser.EquationContext, i)

        def WS(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.WS)
            else:
                return self.getToken(spequationParser.WS, i)

        def EOL(self):
            return self.getToken(spequationParser.EOL, 0)

        def getRuleIndex(self):
            return spequationParser.RULE_equations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterEquations'):
                listener.enterEquations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitEquations'):
                listener.exitEquations(self)

    def equations(self):

        localctx = spequationParser.EquationsContext(
            self, self._ctx, self.state,
        )
        self.enterRule(localctx, 10, self.RULE_equations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self.match(spequationParser.T__3)
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == spequationParser.WS:
                self.state = 56
                self.match(spequationParser.WS)

            self.state = 59
            self.equation()
            self.state = 67
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == spequationParser.T__1:
                self.state = 60
                self.match(spequationParser.T__1)
                self.state = 62
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == spequationParser.WS:
                    self.state = 61
                    self.match(spequationParser.WS)

                self.state = 64
                self.equation()
                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 71
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == spequationParser.EOL:
                self.state = 70
                self.match(spequationParser.EOL)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EquationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i: int=None):
            if i is None:
                return self.getTypedRuleContexts(spequationParser.TermContext)
            else:
                return self.getTypedRuleContext(spequationParser.TermContext, i)

        def WS(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.WS)
            else:
                return self.getToken(spequationParser.WS, i)

        def getRuleIndex(self):
            return spequationParser.RULE_equation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterEquation'):
                listener.enterEquation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitEquation'):
                listener.exitEquation(self)

    def equation(self):

        localctx = spequationParser.EquationContext(
            self, self._ctx, self.state,
        )
        self.enterRule(localctx, 12, self.RULE_equation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 73
            self.term()
            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == spequationParser.WS:
                self.state = 74
                self.match(spequationParser.WS)

            self.state = 77
            self.match(spequationParser.T__4)
            self.state = 79
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == spequationParser.WS:
                self.state = 78
                self.match(spequationParser.WS)

            self.state = 81
            self.term()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base(self):
            return self.getTypedRuleContext(spequationParser.BaseContext, 0)

        def application(self):
            return self.getTypedRuleContext(spequationParser.ApplicationContext, 0)

        def getRuleIndex(self):
            return spequationParser.RULE_term

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterTerm'):
                listener.enterTerm(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitTerm'):
                listener.exitTerm(self)

    def term(self):

        localctx = spequationParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_term)
        try:
            self.state = 85
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 13, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 83
                self.base()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                self.application()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BaseContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPPER(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.UPPER)
            else:
                return self.getToken(spequationParser.UPPER, i)

        def LOWER(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.LOWER)
            else:
                return self.getToken(spequationParser.LOWER, i)

        def getRuleIndex(self):
            return spequationParser.RULE_base

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterBase'):
                listener.enterBase(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitBase'):
                listener.exitBase(self)

    def base(self):

        localctx = spequationParser.BaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_base)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 87
                _la = self._input.LA(1)
                if not(_la == spequationParser.UPPER or _la == spequationParser.LOWER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == spequationParser.UPPER or _la == spequationParser.LOWER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ApplicationContext(ParserRuleContext):

        def __init__(self, parser, parent: ParserRuleContext=None, invokingState: int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base(self):
            return self.getTypedRuleContext(spequationParser.BaseContext, 0)

        def term(self, i: int=None):
            if i is None:
                return self.getTypedRuleContexts(spequationParser.TermContext)
            else:
                return self.getTypedRuleContext(spequationParser.TermContext, i)

        def WS(self, i: int=None):
            if i is None:
                return self.getTokens(spequationParser.WS)
            else:
                return self.getToken(spequationParser.WS, i)

        def getRuleIndex(self):
            return spequationParser.RULE_application

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'enterApplication'):
                listener.enterApplication(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, 'exitApplication'):
                listener.exitApplication(self)

    def application(self):

        localctx = spequationParser.ApplicationContext(
            self, self._ctx, self.state,
        )
        self.enterRule(localctx, 18, self.RULE_application)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.base()
            self.state = 93
            self.match(spequationParser.T__5)
            self.state = 94
            self.term()
            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == spequationParser.T__1:
                self.state = 95
                self.match(spequationParser.T__1)
                self.state = 97
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == spequationParser.WS:
                    self.state = 96
                    self.match(spequationParser.WS)

                self.state = 99
                self.term()
                self.state = 104
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 105
            self.match(spequationParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
